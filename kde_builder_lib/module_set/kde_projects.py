# SPDX-FileCopyrightText: 2013, 2016, 2017 Michael Pyne <mpyne@kde.org>
# SPDX-FileCopyrightText: 2023 - 2024 Andrew Shark <ashark@linuxcomp.ru>
#
# SPDX-License-Identifier: GPL-2.0-or-later

from __future__ import annotations

from typing import TYPE_CHECKING

from .module_set import ModuleSet
# from ..kb_exception import UnknownKdeProjectException
from ..debug import KBLogger
from ..metadata.kde_projects_reader import KDEProjectsReader
from ..module.module import Module

if TYPE_CHECKING:
    from ..build_context import BuildContext

logger_moduleset = KBLogger.getLogger("module-set")


class ModuleSetKDEProjects(ModuleSet):
    """
    Represents a collective grouping of modules that share common options, based on the KDE project repositories.

    Metadata for that repository is itself housed in a dedicated KDE.org git repository "sysadmin/repo-metadata",
    which this class uses to imbue Modules generated by this ModuleSet.

    The only changes here are to allow for expanding out module specifications
    (except for ignored modules), by using KDEProjectsReader.
    """

    # @override
    def convert_to_modules(self) -> list[Module]:
        """
        Convert this module set to a list of Module.

        This function should be called after options are read and build metadata is available.
        Any modules ignored by this module set are excluded from the returned list.
        The modules returned have not been added to the build context.
        """
        use_inactive_projects = self.context.get_option("use-inactive-projects")
        ignore_list: list[str] = self.modules_to_ignore()

        module_list = []  # module names converted to `Module` objects.
        found_modules: set[str] = set()

        # Setup default options for each module
        # Extraction of relevant kde-project modules will be handled immediately
        # after this phase of execution.
        for module_item in self.modules_to_find():
            # We might have already grabbed the right module recursively.
            if module_item in found_modules:
                continue

            module_names: list[str] = self.context.projects_db.get_names_for_search_item(module_item, use_inactive_projects, ignore_list)

            for module_name in module_names:

                new_module = Module(self.context, module_name)

                self._initialize_new_module(new_module)
                new_module.set_scm()
                module_list.append(new_module)

            found_modules.update(module_names)

        if not len(module_list):
            logger_moduleset.warning("No projects were defined for the group " + self.name)
            logger_moduleset.warning("You should use the g[b[use-projects] option to make the group useful.")

        self.project_objects_list = module_list
        return module_list
