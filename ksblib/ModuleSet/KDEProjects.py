import os
import re
from ..Util.Conditional_Type_Enforced import conditional_type_enforced
# from overrides import override

from ..BuildException import BuildException
from ..KDEProjectsReader import KDEProjectsReader
from ..Module.Module import Module
from ..Util.Util import Util

from .ModuleSet import ModuleSet
from ..Debug import Debug


@conditional_type_enforced
class ModuleSet_KDEProjects(ModuleSet):
    """
    This represents a collective grouping of modules that share common options,
    based on the KDE project repositories.  Metadata for that repository is
    itself housed in a dedicated KDE.org git repository "sysadmin/repo-metadata",
    which this class uses to imbue ksb::Modules generated by this ModuleSet.
    
    The only changes here are to allow for expanding out module specifications
    (except for ignored modules), by using KDEProjectsReader.
    
    See also: ModuleSet
    """
    
    def __init__(self, ctx, name):
        ModuleSet.__init__(self, ctx, name)
        self.projectsDataReader = None  # Will be filled in when we get fh
    
    @staticmethod
    def none_true(input_list: list) -> bool:
        return all(not element for element in input_list)
    
    @staticmethod
    def _createMetadataModule(ctx, moduleName) -> Module:
        metadataModule = Module(ctx, re.sub("/", "-", moduleName))
        
        # Hardcode the results instead of expanding out the project info
        metadataModule.setOption({"repository": f"https://invent.kde.org/{moduleName}"})  # Do not use "kde:" alias here, because it may not yet be set at first run, causing git 128 exit status
        metadataModule.setOption({"#kde-project-path": moduleName})
        metadataModule.setScmType("metadata")
        metadataModule.setOption({"branch": "master"})
        metadataModule.setOption({"source-dir":  os.environ.get("XDG_STATE_HOME", os.environ["HOME"] + "/.local/state")})
        
        moduleSet = ModuleSet_KDEProjects(ctx, "<kde-projects dependencies>")
        metadataModule.setModuleSet(moduleSet)
        
        # Ensure we only ever try to update source, not build.
        metadataModule.phases.phases(["update"])
        
        return metadataModule
    
    @staticmethod
    def getProjectMetadataModule(ctx_obj) -> Module:
        """
        Static. Returns a <Module> that can be used to download the
        'repo-metadata' module, which itself contains information on each
        repository in the KDE build system (though currently not
        dependencies).  The module is meant to be held by the <BuildContext>
        
        Parameters:
         ctx - the <ksb::BuildContext> for this script execution.
        """
        from ..BuildContext import BuildContext
        ctx = Util.assert_isa(ctx_obj, BuildContext)
        return ModuleSet_KDEProjects._createMetadataModule(ctx, "sysadmin/repo-metadata")
    
    def _expandModuleCandidates(self, ctx, moduleSearchItem) -> list:
        """
        A class method which goes through the modules in our search list (assumed to
        be found in kde-projects), expands them into their equivalent git modules,
        and returns the fully expanded list. Non kde-projects modules cause an error,
        as do modules that do not exist at all within the database.
        
        *Note*: Before calling this function, the kde-projects database itself must
        have been downloaded first. See getProjectMetadataModule, which ties to the
        BuildContext.
        
        Modules that are part of a module-set requiring a specific branch, that don't
        have that branch, are still listed in the return result since there's no way
        to tell that the branch won't be there.  These should be removed later.
        
        Parameters:
         ctx - The <BuildContext> in use.
         moduleSearchItem - The search description to expand in ksb::Modules. See
         _projectPathMatchesWildcardSearch for a description of the syntax.
        
        Returns:
         @modules - List of expanded git <Modules>.
        
        Throws:
         Runtime - if the kde-projects database was required but couldn't be
         downloaded or read.
         Runtime - if the git-desired-protocol is unsupported.
         Runtime - if an "assumed" kde-projects module was not actually one.
        """
        allModuleResults = ctx.getProjectDataReader().getModulesForProject(moduleSearchItem)
        
        if not allModuleResults:
            BuildException.croak_runtime(f"Unknown KDE project: {moduleSearchItem}")
        
        # It's possible to match modules which are marked as inactive on
        # projects.kde.org, elide those.
        activeResults = allModuleResults
        if not ctx.getOption("use-inactive-modules"):
            activeResults = [module for module in allModuleResults if module.get("active")]
        
        if not activeResults:
            Debug().warning(f" y[b[*] Module y[{moduleSearchItem}] is apparently a KDE collection, but contains no\n" +
                            "active modules to build!")
            
            if allModuleResults:
                count = len(allModuleResults)
                Debug().warning("\tAlthough no active modules are available, there were\n" +
                                f"\t{count} inactive modules. Perhaps the git modules are not ready?")
        
        # Setup module options.
        moduleList = []
        ignoreList = self.modulesToIgnore()
        
        for result in activeResults:
            newModule = Module(ctx, result["name"])
            self._initializeNewModule(newModule)
            
            # Copy metadata from KDE project YAML file
            newModule.setOption({"repository": result["repo"]})
            newModule.setOption({"#kde-project-path": result["fullName"]})
            newModule.setOption({"#kde-repo-path": result.get("inventName", None)})
            newModule.setOption({"#found-by": result["found_by"]})
            # Temp flag during metadata transition
            if "nameChangingTo" in result:
                newModule.setOption({"#upcoming-name-change": result["nameChangingTo"]})
            
            newModule.setScmType("proj")
            
            if self.none_true([KDEProjectsReader._projectPathMatchesWildcardSearch(result["fullName"], element) for element in ignoreList]):
                moduleList.append(newModule)
            else:
                Debug().debug(f"--- Ignoring matched active module {newModule} in module set " + self.name)
        return moduleList
    
    # @override
    def convertToModules(self, ctx) -> list[Module]:
        """
        This function should be called after options are read and build metadata is
        available in order to convert this module set to a list of ksb::Module.
        Any modules ignored by this module set are excluded from the returned list.
        The modules returned have not been added to the build context.
        """
        moduleList = []  # module names converted to ksb::Module objects.
        foundModules = {}
        
        # Setup default options for each module
        # Extraction of relevant kde-project modules will be handled immediately
        # after this phase of execution.
        for moduleItem in self.modulesToFind():
            # We might have already grabbed the right module recursively.
            if moduleItem in foundModules:
                continue
            # eval in case the YAML processor throws an exception.
            try:
                candidateModules = self._expandModuleCandidates(ctx, moduleItem)
            except BuildException as e:
                raise BuildException.croak_runtime(f"The KDE Project database could not be understood: {e}")  # Forward exception objects up
            
            moduleNames = [item.name for item in candidateModules]
            foundModules = {module: 1 for module in moduleNames}
            moduleList.extend(candidateModules)
        
        if not len(moduleList):
            Debug().warning("No modules were defined for the module-set " + self.name)
            Debug().warning("You should use the g[b[use-modules] option to make the module-set useful.")
        
        return moduleList
